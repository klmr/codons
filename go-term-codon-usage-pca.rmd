```{r echo=FALSE}
library(dplyr)
library(xlsx)
library(Biostrings)
library(parallel)

options(stringsAsFactors = FALSE)
```

## GO term gene set data

Load the data for the GO terms. We use the 2012 data here, since we want to
reproduce the results of Gingold *& al.* exactly.

```{r}
go_terms_40 = read.xlsx('./data/GO_2012.xlsx', sheetName = 'GOs_40',
                        header = FALSE)
colnames(go_terms_40) = c('GO', 'Description')
```

Load GO–Gene associations.

```{r}
associations = read.csv('./data/gene_association.goa_human', sep = '\t',
                        comment = '!', quote = '', header = FALSE) %>%
    select(Gene = V3, GO = V5)
```

Join selected GO terms with associations, to retrieve just those GO terms (and
their associated genes) with > 40 hits, and filter out duplicate genes.

```{r}
go_genes = inner_join(go_terms_40, associations, by = 'GO') %>%
    group_by(GO) %>%
    filter(! duplicated(Gene))
```

As a sanity check, let’s see whether all GO terms have > 40 genes.

```{r}
go_genes %>%
    group_by(GO) %>%
    summarize(Genes = n()) %>%
    filter(Genes < 40) %>%
    nrow == 0
```

Great. On to the codon usage.

## Consensus CDS

The consensus CDS information is in a complicated to parse format. Luckily, we
only need the mapping gene name to CCDS ID, and this part is trivial to parse.

```{r}
ccds_info = read.csv('./data/CCDS.current.txt', sep = '\t') %>%
    select(Gene = gene, CCDS = ccds_id, Status = ccds_status) %>%
    filter(Status != 'Withdrawn') %>%
    select(-Status)
```

Now load the actual CCDS from (gzipped) Fasta.

```{r}
ccds = readDNAStringSet('./data/CCDS_nucleotide.current.fna.gz')
names(ccds) = sub('\\|.*', '', names(ccds))
```

We are going to use, as a gene’s codon usage, the mean codon usage of all its
annotated coding sequences.

```{r}
existing_ccds = ccds_info$CCDS[match(names(ccds), ccds_info$CCDS)]
```

`ccds_info` now contains duplicate CCDS IDs. We filter these out.

```{r}
ccds_info = filter(ccds_info, ! duplicated(CCDS))
```

Next retrieve the CCDS sequences.

```{r}
all_ccds = ccds_info %>%
    filter(CCDS %in% existing_ccds) %>%
    mutate(Seq = as.character(ccds[CCDS]))
```

Sanity check: every length is divisible by three.

```{r}
! any(nchar(all_ccds$Seq) %% 3 != 0)
```

Bummer. Log and remove those. And make sure they *are* removed.

```{r}
invalid_cds = all_ccds %>% filter(nchar(Seq) %% 3 != 0)
invalid_cds$CCDS

all_ccds = all_ccds %>% filter(nchar(Seq) %% 3 == 0)
! any(all_ccds$Length %% 3 != 0)
```

Good.

## Codon usage

Define a helper function to calculate the codon usage.

```{r}
codon_usage = function (sequence) {
    codons = as.character(codons(DNAString(sequence)))
    freqs = table(codons)
    all_codons = names(GENETIC_CODE)
    all_codon_freqs = setNames(rep(0, length(all_codons)), all_codons)
    all_codon_freqs[names(freqs)] = freqs
    all_codon_freqs
}
```

Now create a table with the codon usage for every CDS.

```{r cache=TRUE}
ncores = detectCores()
ccds_codon_usage = all_ccds %>%
    mutate(CU = mclapply(Seq, codon_usage, mc.cores = ncores)) %>%
    select(CCDS, Gene, CU)

# ERROR: not compatible with STRSXP
#ccds_codon_freq = ccds_codon_usage %>%
#    mutate(CU = list(list(CU[[1]] / sum(CU[[1]]))))
# TOO SLOW (VERY!)
#ccds_codon_freq = ccds_codon_usage %>%
#    group_by(CCDS) %>%
#    do(CU = list(.$CU[[1]] / sum(.$CU[[1]]))) %>%
#    ungroup()

ccds_codon_freq = ccds_codon_usage
for (i in 1 : nrow(ccds_codon_freq)) {
    CU = ccds_codon_freq[i, 'CU'][[1]]
    ccds_codon_freq[i, 'CU'] = list(list(CU / sum(CU)))
}
```

And, from that, a table with the codon usage for every gene.

```{r cache=TRUE}
gene_codon_usage = ccds_codon_usage %>%
    group_by(Gene) %>%
    mutate(CU = list(rowMeans(do.call(cbind, CU)))) %>%
    select(Gene, CU) %>%
    filter(row_number() == 1)

gene_codon_freq = ccds_codon_freq %>%
    group_by(Gene) %>%
    mutate(CU = list(rowMeans(do.call(cbind, CU)))) %>%
    select(Gene, CU) %>%
    filter(row_number() == 1)
```

Using that, we can generate the mean per-GO codon usage.

```{r cache=TRUE}
go_cu = inner_join(gene_codon_freq, go_genes, by = 'Gene') %>%
    group_by(GO) %>%
    mutate(CU = list(rowMeans(do.call(cbind, CU)))) %>%
    select(GO, CU) %>%
    filter(row_number() == 1)
```

We now compute the principal components for the codon usage and plot them.

```{r}
pctable = `colnames<-`(do.call(cbind, go_cu$CU), go_cu$GO)
pc = prcomp(t(pctable), scale. = TRUE)

pc_plot = function (pc, pc1 = 1, pc2 = 2, main = deparse(substitute(pc)),
                    pch, col, ...) {
    if (missing(pch))
        pch = 19
    if (missing(col))
        col = '#00000040'
    v1 = summary(pc)$importance[2, pc1] * 100
    v2 = summary(pc)$importance[2, pc2] * 100
    plot(pc$x[, pc1], pc$x[, pc2], main = main,
         xlab = sprintf('PC%d (%.0f%% variance explained)', pc1, v1),
         ylab = sprintf('PC%d (%.0f%% variance explained)', pc2, v2),
         pch = pch, col = col, ...)
}

pc_plot(pc, main = 'GO terms by their mean codon usage (using CCDS)')
```

Add colours according to the GO categories, as done in the paper by Gingold
*&al.*.

```{r}
categories = list(`Multi-cellular` = c(Development = 24,
                                       Differentiation = 21,
                                       `Cell adhesion` = 22,
                                       `Pattern specification` = 23,
                                       `Multicellular organism growth` = 11,
                                       Angiogenesis = 8),
                  `Cell autonomous` = c(`Mitotic cell cycle` = 24,
                                        `Nucleosome assembly` = 21,
                                        `Chromatin remodeling` = 22,
                                        `Chromatin modification` = 22,
                                        Translation = 23,
                                        `mRNA metabolic process` = 11,
                                        `Negative regulation of cell cycle` = 6))

category_names = unlist(lapply(categories, names))
category_symbol = setNames(do.call(c, categories), category_names)
category_color = setNames(c(rep('blue', length(categories[[1]])),
                            rep('red', length(categories[[2]]))),
                          category_names)

go_term_match_indices = match(go_terms_40$GO, colnames(pctable))
go_indices = setNames(sapply(category_names, grep, go_terms_40$Description,
                             ignore.case = TRUE),
                      category_names)

go_category_map = sapply(go_indices, function (i) colnames(pctable)[go_term_match_indices][i])
category_for_go = unlist(go_category_map)
category_for_go = setNames(names(category_for_go), category_for_go)
category_for_go = sub('\\d+$', '', category_for_go)

# Quick and dirty plot to check placement of categories.
pcx = pc$x
cat = unname(category_for_go[rownames(pcx)])
pc_plot(pc, main = 'GO terms by their mean codon usage',
        pch = ifelse(is.na(cat), 19, category_symbol[cat]),
        col = ifelse(is.na(cat), '#00000040', category_color[cat]),
        bg = category_color[cat])
```

Just for the record, here’s the same but using raw codon counts rather than
frequencies.

```{r cache=TRUE}
go_cu_count = inner_join(gene_codon_usage, go_genes, by = 'Gene') %>%
    group_by(GO) %>%
    mutate(CU = list(rowMeans(do.call(cbind, CU)))) %>%
    select(GO, CU) %>%
    filter(row_number() == 1)
```

```{r}
pctable_count = `colnames<-`(do.call(cbind, go_cu_count$CU), go_cu_count$GO)
pc_count = prcomp(t(pctable_count))
stopifnot(all.equal(rownames(pc$x), rownames(pc_count$x)))
pc_plot(pc_count, main = 'GO terms by their mean codon counts',
        pch = ifelse(is.na(cat), 19, category_symbol[cat]),
        col = ifelse(is.na(cat), '#00000040', category_color[cat]),
        bg = category_color[cat])
```

Do a PCA by amino acid usage rather than codon usage.

```{r}
genetic_code = read.delim('./data/genetic_code.tsv', header = FALSE,
                          col.names = c('Codon', 'AA'))

aa_indices = match(genetic_code$Codon, rownames(pctable))
pctable_aa = do.call(rbind, by(pctable, genetic_code$AA[aa_indices], colSums))
pc_aa = prcomp(t(pctable_aa), scale. = TRUE)

stopifnot(all.equal(rownames(pc$x), rownames(pc_aa$x)))
pc_plot(pc_aa, main = 'GO terms by their amino acid usage',
        pch = ifelse(is.na(cat), 19, category_symbol[cat]),
        col = ifelse(is.na(cat), '#00000040', category_color[cat]),
        bg = category_color[cat])
```

Investigate the gene set size of the GO categories.

```{r}
go_sizes = go_genes %>%
    group_by(GO) %>%
    summarize(Size = n())

go_sizes = with(go_sizes, setNames(Size, GO))

plot(pcx[, 1], sapply(go_sizes[rownames(pcx)], min, 500),
     main = 'PC1 of GO terms by codon usage against gene set size',
     col = ifelse(is.na(cat), '#00000040', category_color[cat]),
     pch = ifelse(go_sizes[rownames(pcx)] > 500, 17, 16), ylim = c(40, 500),
     xlab = 'PC1', ylab = 'Gene set size')
```

```{r}
gc_content = function (str)
    nchar(gsub('[AT]', '', str)) / nchar(str)

ccds_gc = all_ccds %>% mutate(GC = gc_content(Seq))
gene_gc = ccds_gc %>%
    group_by(Gene) %>%
    summarize(GC = mean(GC))
go_gc = inner_join(go_genes, gene_gc, by = 'Gene') %>%
    group_by(GO) %>%
    summarize(GC = mean(GC))

#### DOUBLE-CHECKING THIS:

#smallest_go_genes = which.min(go_sizes) %>% names
#heart_genes = go_genes %>% filter(GO == smallest_go_genes) %>% .$Gene
#
#gene_new_heart = ccds_gc %>% filter(Gene %in% heart_genes)
#
#gene_gc_new_heart  = gene_new_heart$Seq %>% gc_content

######

go_gc = setNames(go_gc$GC, go_gc$GO)

plot(pcx[, 1], go_gc[rownames(pcx)])
```
