```{r echo=FALSE}
library(dplyr)
library(xlsx)
library(Biostrings)
library(parallel)

options(stringsAsFactors = FALSE)
```

## GO term gene set data

Load the data for the GO terms. We use the 2012 data here, since we want to
reproduce the results of Gingold *& al.* exactly.

```{r}
go_terms_40 = read.xlsx('./data/GO_2012.xlsx', sheetName = 'GOs_40',
                        header = FALSE)
colnames(go_terms_40) = c('GO', 'Description')
```

Load GO–Gene associations.

```{r}
associations = read.csv('./data/gene_association.goa_human', sep = '\t',
                        comment = '!', quote = '', header = FALSE) %>%
    select(Gene = V3, GO = V5)
```

Join selected GO terms with associations, to retrieve just those GO terms (and
their associated genes) with > 40 hits, and filter out duplicate genes.

```{r}
go_genes = inner_join(go_terms_40, associations, by = 'GO') %>%
    group_by(GO) %>%
    filter(! duplicated(Gene))
```

As a sanity check, let’s see whether all GO terms have > 40 genes.

```{r}
go_genes %>%
    group_by(GO) %>%
    summarize(Genes = n()) %>%
    filter(Genes < 40) %>%
    nrow == 0
```

Great. On to the codon usage.

## Consensus CDS

The consensus CDS information is in a complicated to parse format. Luckily, we
only need the mapping gene name to CCDS ID, and this part is trivial to parse.

```{r}
ccds_info = read.csv('./data/CCDS.current.txt', sep = '\t') %>%
    select(Gene = gene, CCDS = ccds_id, Status = ccds_status) %>%
    filter(Status != 'Withdrawn') %>%
    select(-Status)
```

Now load the actual CCDS from (gzipped) Fasta.

```{r}
ccds = readDNAStringSet('./data/CCDS_nucleotide.current.fna.gz')
names(ccds) = sub('\\|.*', '', names(ccds))
```

We are going to use, as a gene’s codon usage, the mean codon usage of all its
annotated coding sequences.

```{r}
existing_ccds = ccds_info$CCDS[match(names(ccds), ccds_info$CCDS)]
```

`ccds_info` now contains duplicate CCDS IDs. We filter these out.

```{r}
ccds_info = filter(ccds_info, ! duplicated(CCDS))
```

Next retrieve the CCDS sequences.

```{r}
all_ccds = ccds_info %>%
    filter(CCDS %in% existing_ccds) %>%
    mutate(Seq = as.character(ccds[CCDS]))
```

Sanity check: every length is divisible by three.

```{r}
! any(nchar(all_ccds$Seq) %% 3 != 0)
```

Bummer. Log and remove those. And make sure they *are* removed.

```{r}
invalid_cds = all_ccds %>% filter(nchar(Seq) %% 3 != 0)
invalid_cds$CCDS

all_ccds = all_ccds %>% filter(nchar(Seq) %% 3 == 0)
! any(all_ccds$Length %% 3 != 0)
```

Good.

## Codon usage

Define a helper function to calculate the codon usage.

```{r}
codon_usage = function (sequence) {
    codons = as.character(codons(DNAString(sequence)))
    freqs = table(codons)
    all_codons = names(GENETIC_CODE)
    all_codon_freqs = setNames(rep(0, length(all_codons)), all_codons)
    all_codon_freqs[names(freqs)] = freqs
    all_codon_freqs
}
```

Now create a table with the codon usage for every CDS.

```{r}
ncores = detectCores()
ccds_codon_usage = all_ccds %>%
    mutate(CU = mclapply(Seq, codon_usage, mc.cores = ncores)) %>%
    select(CCDS, Gene, CU)

# ERROR: not compatible with STRSXP
#ccds_codon_freq = ccds_codon_usage %>%
#    mutate(CU = list(list(CU[[1]] / sum(CU[[1]]))))
# TOO SLOW (VERY!)
#ccds_codon_freq = ccds_codon_usage %>%
#    group_by(CCDS) %>%
#    do(CU = list(.$CU[[1]] / sum(.$CU[[1]]))) %>%
#    ungroup()

ccds_codon_freq = ccds_codon_usage
for (i in 1 : nrow(ccds_codon_freq)) {
    CU = ccds_codon_freq[i, 'CU'][[1]]
    ccds_codon_freq[i, 'CU'] = list(list(CU / sum(CU)))
}
```

And, from that, a table with the codon usage for every gene.

```{r}
gene_codon_usage = ccds_codon_usage %>%
    group_by(Gene) %>%
    mutate(CU = list(rowMeans(do.call(cbind, CU)))) %>%
    select(Gene, CU) %>%
    filter(row_number() == 1)

gene_codon_freq = ccds_codon_freq %>%
    group_by(Gene) %>%
    mutate(CU = list(rowMeans(do.call(cbind, CU)))) %>%
    select(Gene, CU) %>%
    filter(row_number() == 1)
```

Using that, we can generate the mean per-GO codon usage.

```{r}
go_cu = inner_join(gene_codon_freq, go_genes, by = 'Gene') %>%
    group_by(GO) %>%
    mutate(CU = list(rowMeans(do.call(cbind, CU)))) %>%
    select(GO, CU) %>%
    filter(row_number() == 1)
```

We now compute the principal components for the codon usage and plot them.

```{r}
pctable = `colnames<-`(do.call(cbind, go_cu$CU), go_cu$GO)
pc = prcomp(pctable)

pc_plot = function (pc, pc1 = 1, pc2 = 2, main = deparse(substitute(pc)),
                    pch, col, ...) {
    if (missing(pch))
        pch = 19
    if (missing(col))
        col = '#00000040'
    v1 = summary(pc)$importance[2, pc1] * 100
    v2 = summary(pc)$importance[2, pc2] * 100
    plot(pc$rotation[, pc1], pc$rotation[, pc2], main = main,
         xlab = sprintf('PC%d (%.0f%% variance explained)', pc1, v1),
         ylab = sprintf('PC%d (%.0f%% variance explained)', pc2, v2),
         pch = pch, col = col, ...)
}

pc_plot(pc, main = 'GO terms by their mean codon usage (using CCDS)')
```

Add colours according to the GO categories, as done in the paper by Gingold
*&al.*.

```{r}
categories = list(`Multi-cellular` = c(Development = 24,
                                       Differentiation = 21,
                                       `Cell adhesion` = 22,
                                       `Pattern specification` = 23,
                                       `Multicellular organism growth` = 11,
                                       Angiogenesis = 8),
                  `Cell autonomous` = c(`Mitotic cell cycle` = 24,
                                        `Nucleosome assembly` = 21,
                                        `Chromatin remodeling` = 22,
                                        `Chromatin modification` = 22,
                                        Translation = 23,
                                        `mRNA metabolic process` = 11,
                                        `Negative regulation of cell cycle` = 6))

category_names = unlist(lapply(categories, names))
category_symbol = setNames(do.call(c, categories), category_names)
category_color = setNames(c(rep('blue', length(categories[[1]])),
                            rep('red', length(categories[[2]]))),
                          category_names)

go_indices = setNames(sapply(category_names, grep, go_terms_40$Description,
                             ignore.case = TRUE),
                      category_names)

go_category_map = sapply(go_indices, function (i) colnames(pctable)[i])
category_for_go = unlist(go_category_map)
category_for_go = setNames(names(category_for_go), category_for_go)
category_for_go = sub('\\d+$', '', category_for_go)

# Quick and dirty plot to check placement of categories.
pcr = pc$rotation
cat = unname(category_for_go[rownames(pcr)])
pc_plot(pc, main = 'GO terms by their mean codon usage',
        pch = ifelse(is.na(cat), 19, category_symbol[cat]),
        col = ifelse(is.na(cat), '#00000040', category_color[cat]),
        bg = category_color[cat])
```
